# Generics and when to use them in Go 

Paul Bivrell
1 November 2021
Slack: @pbj

## Overview of the Generic syntax

## Constraints the concept

A type constraint defines the set of methods and operators a type must have to be usable generically

Because of their functional similarity to interfaces we can reuse that syntax.

.code -edit src/constraints.go /START_STRINGER OMIT/,/END_WRITER OMIT/



## Type Sets in Constraints

We can also now add type sets to interfaces to define the operators that are permitted.

.code -edit src/constraints.go /START_ONLYSIGNED OMIT/,/END_ONLYSIGNED OMIT/

This creates a constraint that can use all of the following operators (*,  /,  %,  <<,  >>,  &,  &^, +,  -, |, ^, ==, !=, <, <=, >, >=)

The constraint above only matches things that are exactly int, int8, int16, int32, and int64. For example BetterInt would not be acceptable as an OnlySignedInt.

.code -edit src/constraints.go /START_BETTERTYPE OMIT/,/END_BETTERTYPE OMIT/

## Type approximation elements

To include a type who's underlying type is another type we use the approximation element syntax

.code -edit src/constraints.go /START_SIGNED OMIT/,/END_SIGNED OMIT/

## Method and type sets in constraint

Unsurprisingly we can use combinations of methods and type sets to further specify the constraint 

.code -edit src/constraints.go /START_ABSOLUTE OMIT/,/END_ABSOLUTE OMIT/

## Predeclared constraints

There are two predeclared type constraints `any` and `comparable`
* any is an alias for interface{}. Which is just useful short hand for all types
* comparable is all types that you can use == and != on

## Generic Functions

## Generic Function syntax

We use type constraints to write functions on generic data.

.code -edit src/functions1.go /START_FUNC OMIT/,/END_FUNC OMIT/

We can call this function by passing the type of our data as a type argument

.code -edit src/functions1.go /START_CALLS1 OMIT/,/END_CALLS1 OMIT/

Using type inference we can omit the type argument

.code -edit src/functions1.go /START_CALLS2 OMIT/,/END_CALLS2 OMIT/

## Generic Search

Perhaps a more practical example of function

.code -edit src/functions2.go /START_FUNC OMIT/,/END_FUNC OMIT/

## Using generic search

.play -edit src/functions2.go /START_CALLS OMIT/,/END_CALLS OMIT/

## Generic Types

## Generic type

Performing functions on generic data in itself is useful. However go 1.18 offers us even more power with generic types. 

A generic type can contain any one type that matches it's constraint.

.code -edit src/stack.go /START_STACK OMIT/,/END_STACK OMIT/

## Using generic types

.code -edit src/stack.go /START_MAIN OMIT/,/END_MAIN OMIT/

Important note a generic type can contain only the type specified when it's instantiated

## Another container example

Type parameters can be values in struct

.code -edit src/queue.go /START_TYPE OMIT/,/END_TYPE OMIT/

## Queue methods

.code -edit src/queue.go /START_FUNC OMIT/,/END_FUNC OMIT/

## Queue usage

.code -edit src/queue.go /START_MAIN OMIT/,/END_MAIN OMIT/

## Non container example

We can have multiple same or different type parameters 

.code -edit src/map.go /START_FUNC OMIT/,/END_FUNC OMIT/

## Map usage


.code -edit src/map.go /START_MAIN OMIT/,/END_MAIN OMIT/



## Guidelines

**Write non generic code**

Use the following to see if your code is canadiate for generics

1. Are you duplicating code
2. Is there a set (n > 1) of types that your code can operate on
3. Will the user of my code be willing to specify a type parameter

**Final thoughts**

So far I think generics are most valuable for collections and operations on collections. As such I think it is unlikely that you should often write generic code. Though you may frequently use generic code.
